package datamodeling

import (
	"github.com/twhello/aws-to-go/services/dynamodb"
	"github.com/twhello/aws-to-go/util/uuid"
	"bytes"
	"encoding/gob"
	"log"
	"reflect"
	"time"
)

var range_list = []string{
	"DynamoDBAttribute", "DynamoDBHashKey", "DynamoDBRangeKey",
	"DynamoDBVersionAttribute", "DynamoDBIndexHashKey", "DynamoDBIndexRangeKey",
}

// Contains attribute values and some table metadata.
type DataModel struct {
	TableName        string
	Item             map[string]dynamodb.AttributeValue
	HashKey          string
	RangeKey         string
	IndexHashKey     string
	IndexRangeKey    string
	VersionAttribute string
}

/*
Marshal returns the AttributeValue encoding of v.

Example of supported types:

	type SampleMapper struct {
	    DynamoDBTable string    `DynamoDBTable:"TableName"`
	    HashKey       string    `DynamoDBHashKey:"HashKey" DynamoDBAutoGeneratedKey:"true"`
	    RangeKey      string    `DynamoDBRangeKey:"RangeKey"`
	    IndexHashKey  string    `DynamoDBIndexHashKey:"IndexHashKey"`
	    IndexRangeKey string    `DynamoDBIndexRangeKey:"IndexRangeKey"`
	    ParamOne      string    `DynamoDBAttribute:"ParamOne"`
	    BoolVal       string    `DynamoDBAttribute:"BoolVal" DynamoDBType:"STRING"`
	    IntArr        []int     `DynamoDBAttribute:"IntArr"`
	    Version       uint64    `DynamoDBVersionAttribute:"Version"`
	    DateTime      time.Time `DynamoDBAttribute:"DateTime" DynamoDBType:"STRING" DynamoDBTimeFormat:"2006-01-02T15:04:05Z07:00"`
	}

Supports the following field types and arrays:
bool, byte, float32, float64, int, int8, int16, int32, int64, rune, string, uint, uint8, uint16, uint32, uint64

Also supports the `time.Time` type.

Does not support pointers.

Other types are serialized into a BINARY attribute. Only compatible with this Go SDK.

Notes:
- The float32 type will convert to float64 with precision side-effects. Use float64, whenever possible.
- The bool type resolves to S:"true|false", N:1|0 or B:[]byte{0,1|0,0}.
- The time.Time type resolves to UTC S:time.RFC3339Nano|Custom, N:Time.UnixNano() or B:[]byte

Tags for Data Mapping structs:

At lease one of the following tags is required on each attribute field:
"DynamoDBAttribute", "DynamoDBHashKey", "DynamoDBRangeKey", "DynamoDBVersionAttribute",
"DynamoDBIndexHashKey", "DynamoDBIndexRangeKey"

DynamoDBTable:"tableName"
Tag to set the DynamoDB table name. The field name and value are ignored. If this tag is not present,
the struct name will be used as the table name.

DynamoDBAttribute:"attributeName"
Tags a field as an attribute in a DynamoDB table.

DynamoDBType:"STRING"
Tags a field as an attribute type in a DynamoDB table. Required for bool and time.Time types.
Valid values: STRING or S, NUMBER or N, and BINARY or B. Default: STRING.

DynamoDBTimeFormat:"2006-01-02T15:04:05Z07:00"
Tags a time.Time field mapping to a STRING attribute with a format layout. Default: time.RFC3339Nano.

DynamoDBVersionAttribute:"attributeName"
Tags a field as an optimistic locking version attribute.

DynamoDBHashKey:"attributeName"
Tags a field as the hash key for a modeled struct.

DynamoDBRangeKey:"attributeName"
Tags a field in a struct as the range key for a DynamoDB table.

DynamoDBIndexHashKey:"attributeName"
Tags a field in a struct as the attribute to be used as the hash key for one or more
global secondary indexes on a DynamoDB table.

DynamoDBIndexRangeKey:"attributeName"
Tags a field in a struct as the attribute to be used as range key for one or more
local secondary indexes on a DynamoDB table.

DynamoDBAutoGeneratedKey:"true"
Tag for marking a hash key or range key property in a struct to auto-generate this key.
Only String typed keys can be auto generated, and are given a random UUID.

[http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html]*/
func Marshal(v interface{}) *DataModel {

	e := reflect.ValueOf(v).Elem()
	t := e.Type()

	model := &DataModel{TableName: t.Name(), Item: make(map[string]dynamodb.AttributeValue)}

	for i := 0; i < e.NumField(); i++ {

		f, ft := e.Field(i), t.Field(i).Tag

		if val := ft.Get("DynamoDBTable"); val != "" {
			model.TableName = val
			continue
		}

		for _, tag := range range_list {

			// Check if the field contains the tag.
			if val := ft.Get(tag); val != "" {

				switch tag {
				case "DynamoDBHashKey":
					model.HashKey = val
				case "DynamoDBRangeKey":
					model.RangeKey = val
				case "DynamoDBIndexHashKey":
					model.IndexHashKey = val
				case "DynamoDBIndexRangeKey":
					model.IndexRangeKey = val
				case "DynamoDBVersionAttribute":
					model.VersionAttribute = val
				}

				switch f.Type().String() {
				case "time.Time":
					if datetime, ok := f.Interface().(time.Time); ok {
						switch ft.Get("DynamoDBType") {
						case "N", "NUMBER", "n", "number":
							model.Item[val] = dynamodb.NewIntAttributeValue(datetime.UnixNano())
						case "B", "BINARY", "b", "binary":
							b, _ := datetime.GobEncode()
							model.Item[val] = dynamodb.NewBinaryAttributeValue(b)
						default:
							if timeFormat := ft.Get("DynamoDBTimeFormat"); timeFormat != "" {
								model.Item[val] = dynamodb.NewAttributeValue(datetime.UTC().Format(timeFormat))
							} else {
								model.Item[val] = dynamodb.NewAttributeValue(datetime.UTC().Format(time.RFC3339Nano))
							}
						}
					} else {
						log.Printf("The field `%s` could not be converted to time.Time.\n", f.Type().Name())
						log.Printf("%+v\n", v)
					}

				case "string":
					if f.String() == "" && ft.Get("DynamoDBAutoGeneratedKey") != "" {
						model.Item[val] = dynamodb.NewAttributeValue(uuid.NewUUID().String()[1:37])
					} else {
						model.Item[val] = dynamodb.NewAttributeValue(f.String())
					}

				case "[]string":
					if arr, ok := f.Interface().([]string); ok {
						model.Item[val] = dynamodb.NewAttributeSet(arr)
					}

				case "int", "int8", "int16", "int32", "int64", "rune":
					model.Item[val] = dynamodb.NewIntAttributeValue(f.Int())

				case "[]int", "[]int8", "[]int16", "[]int32", "[]int64", "[]rune":
					intArr := make([]int64, f.Len())
					for j := 0; j < f.Len(); j++ {
						intArr[j] = f.Index(j).Int()
					}
					model.Item[val] = dynamodb.NewIntAttributeSet(intArr)

				case "uint", "uint8", "uint16", "uint32", "uint64", "byte":
					model.Item[val] = dynamodb.NewUintAttributeValue(f.Uint())

				case "[]uint", "[]uint8", "[]uint16", "[]uint32", "[]uint64":
					uintArr := make([]uint64, f.Len())
					for j := 0; j < f.Len(); j++ {
						uintArr[j] = f.Index(j).Uint()
					}
					model.Item[val] = dynamodb.NewUintAttributeSet(uintArr)

				case "float32", "float64":
					model.Item[val] = dynamodb.NewFloatAttributeValue(f.Float())

				case "[]float32", "[]float64":
					fltArr := make([]float64, f.Len())
					for j := 0; j < f.Len(); j++ {
						fltArr[j] = f.Index(j).Float()
					}
					model.Item[val] = dynamodb.NewFloatAttributeSet(fltArr)

				case "[]byte":
					model.Item[val] = dynamodb.NewBinaryAttributeValue(f.Bytes())

				case "[][]byte":
					if arr, ok := f.Interface().([][]byte); ok {
						model.Item[val] = dynamodb.NewBinaryAttributeSet(arr)
					}

				case "bool":
					switch ft.Get("DynamoDBType") {
					case "N", "NUMBER", "n", "number":
						if f.Bool() {
							model.Item[val] = dynamodb.AttributeValue{N: "1"}
						} else {
							model.Item[val] = dynamodb.AttributeValue{N: "0"}
						}
					case "B", "BINARY", "b", "binary":
						if f.Bool() {
							model.Item[val] = dynamodb.AttributeValue{B: []byte{1}}
						} else {
							model.Item[val] = dynamodb.AttributeValue{B: []byte{0}}
						}
					default:
						if f.Bool() {
							model.Item[val] = dynamodb.AttributeValue{S: "true"}
						} else {
							model.Item[val] = dynamodb.AttributeValue{S: "false"}
						}
					}

				case "[]bool":
					switch ft.Get("DynamoDBType") {
					case "N", "NUMBER", "n", "number":
						numArr := make([]string, f.Len())
						for j := 0; j < f.Len(); j++ {
							if f.Index(j).Bool() {
								numArr[j] = "1"
							} else {
								numArr[j] = "0"
							}
						}
						model.Item[val] = dynamodb.AttributeValue{NS: numArr}

					case "B", "BINARY", "b", "binary":
						binArr := make([][]byte, f.Len())
						for j := 0; j < f.Len(); j++ {
							if f.Index(j).Bool() {
								binArr[j] = []byte{1}
							} else {
								binArr[j] = []byte{0}
							}
						}
						model.Item[val] = dynamodb.AttributeValue{BS: binArr}

					default:
						strArr := make([]string, f.Len())
						for j := 0; j < f.Len(); j++ {
							if f.Index(j).Bool() {
								strArr[j] = "true"
							} else {
								strArr[j] = "false"
							}
						}
						model.Item[val] = dynamodb.AttributeValue{SS: strArr}
					}

				default:
					var buf bytes.Buffer
					enc := gob.NewEncoder(&buf)
					enc.Encode(f.Interface())
					model.Item[val] = dynamodb.NewBinaryAttributeValue(buf.Bytes())
				}
				break
			}
		}
	}

	return model
}

// Unmarshal parses the AttributeValue data and stores the result in the value pointed to by v.
func Unmarshal(item map[string]dynamodb.AttributeValue, v interface{}) {

	e := reflect.ValueOf(v).Elem()
	t := e.Type()

	for i := 0; i < e.NumField(); i++ {

		f, ft := e.Field(i), t.Field(i).Tag

		for _, tag := range range_list {

			// Check if the field contains the tag.
			if val := ft.Get(tag); val != "" {

				if attribute, ok := item[val]; ok {

					attrType := attribute.Type()

					switch f.Type().String() {
					case "time.Time":
						if attrType == dynamodb.STRING {
							timeFormat := time.RFC3339Nano
							if ft.Get("DynamoDBTimeFormat") != "" {
								timeFormat = ft.Get("DynamoDBTimeFormat")
							}
							datetime, _ := time.Parse(timeFormat, attribute.Value())
							f.Set(reflect.ValueOf(datetime))
						} else if attrType == dynamodb.NUMBER {
							datetime := time.Unix(0, attribute.Int())
							f.Set(reflect.ValueOf(datetime))
						} else {
							datetime := time.Now()
							datetime.GobDecode(attribute.Binary())
							f.Set(reflect.ValueOf(datetime))
						}

					case "string":
						if attrType == dynamodb.STRING {
							f.SetString(attribute.Value())
						} else {
							log.Printf("Field `%s` was expecting a STRING, but got a %s.", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[]string":
						if attrType == dynamodb.STRING {
							vLen := len(attribute.SS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.ValueSet() {
								slice.Index(i).SetString(sVal)
							}
							f.Set(slice)
						} else {
							log.Printf("Field `%s` was expecting a STRING, but got a %s.", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "int", "int8", "int16", "int32", "int64", "rune":
						if attrType == dynamodb.NUMBER {
							f.SetInt(attribute.Int())
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[]int", "[]int8", "[]int16", "[]int32", "[]int64", "[]rune":
						if attrType == dynamodb.NUMBER {
							vLen := len(attribute.NS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.IntSet() {
								slice.Index(i).SetInt(sVal)
							}
							f.Set(slice)
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "uint", "uint8", "uint16", "uint32", "uint64", "byte":
						if attrType == dynamodb.NUMBER {
							f.SetUint(attribute.Uint())
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[]uint", "[]uint8", "[]uint16", "[]uint32", "[]uint64":
						if attrType == dynamodb.NUMBER {
							vLen := len(attribute.NS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.UintSet() {
								slice.Index(i).SetUint(sVal)
							}
							f.Set(slice)
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "float32", "float64":
						if attrType == dynamodb.NUMBER {
							f.SetFloat(attribute.Float())
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[]float32", "[]float64":
						if attrType == dynamodb.NUMBER {
							vLen := len(attribute.NS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.FloatSet() {
								slice.Index(i).SetFloat(sVal)
							}
							f.Set(slice)
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[]byte":
						if attrType == dynamodb.BINARY {
							f.SetBytes(attribute.Binary())
						} else {
							log.Printf("Field `%s` was expecting a NUMBER, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "[][]byte":
						if attrType == dynamodb.BINARY {
							vLen := len(attribute.BS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.BinarySet() {
								slice.Index(i).SetBytes(sVal)
							}
							f.Set(slice)
						} else {
							log.Printf("Field `%s` was expecting a BINARY, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}

					case "bool":
						if attrType == dynamodb.STRING {
							f.SetBool(attribute.Value() == "true")
						} else if attrType == dynamodb.NUMBER {
							f.SetBool(attribute.N == "1")
						} else {
							f.SetBool(attribute.Binary()[0] == 1)
						}

					case "[]bool":
						if attrType == dynamodb.STRING {
							vLen := len(attribute.SS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.SS {
								slice.Index(i).SetBool(sVal == "true")
							}
							f.Set(slice)
						} else if attrType == dynamodb.NUMBER {
							vLen := len(attribute.NS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.NS {
								slice.Index(i).SetBool(sVal == "1")
							}
							f.Set(slice)
						} else {
							vLen := len(attribute.BS)
							slice := reflect.MakeSlice(f.Type(), vLen, vLen)
							for i, sVal := range attribute.BinarySet() {
								slice.Index(i).SetBool(sVal[0] == 1)
							}
							f.Set(slice)
						}

					default:
						if attrType == dynamodb.BINARY {
							reader := bytes.NewReader(attribute.Binary())
							q := reflect.New(f.Type()).Interface()
							gob.NewDecoder(reader).Decode(q)
							f.Set(reflect.Indirect(reflect.ValueOf(q)))
						} else {
							log.Printf("Field `%s` was expecting a BINARY, but got a %s.\n", f.Type().Name(), attrType)
							log.Printf("%+v\n", item)
						}
					}
				}
				break
			}
		}
	}

	return
}
